# 스프링 스터디 - 2회

## 개요
[스프링 핵심 원리 기본편](https://www.inflearn.com/course/스프링-핵심-원리-기본편)을 보고 정리하는 스터디

## 기간
2021.08.30 ~ 09.05 (7일간)

## 목표
기술을 사용하는 것에서 떠나, 어떻게 실무에서 활용하는지와 원리, 핵심을 중점으로 확인한다. 이를 통해 단순한 사용보다 더 깊은 이해와 설계가 가능하도록 한다.

## 스프링
스프링 이전에는, Enterprise Java Beans(EJB)라는 기술이 표준 기술이었다. 이론은 정말 좋았지만, 어렵고 비쌌다. 이를 대체하면서 더 좋은 방법을 만들게 되었고 이것이 Spring의 시작이 되었다. 이 과정에서 Hibernate를 이용해 JPA 표준을 만들어지곤 했다.

처음에는 xml과 함께 많은 기능을 사용했는데, 스프링 프레임워크에서는 서버 기능 등을 따로 추가하고 관리해야했다. 스프링 부트가 추가되면서 프로젝트 구성을 편리하게 할 수 있고, 리액티브 프로그래밍(데이터의 흐름에 따라 처리하는 프로그래밍 방향. 데이터가 변경될 때마다 이벤트를 발생시킨다.)을 지원하게 됐다.

지금의 스프링은 스프링 프레임워크를 사용한 그 생태계 전반을 일컫는 용어로서 사용하고 있다.

### 스프링의 기술들
스프링은 여러 기술들의 모음으로 볼 수 있다. 필수로 `스프링 프레임워크`와 `스프링 부트`를 묶어서 보고, 필요에 따라 `스프링 데이터`, `스프링 세션`, `스프링 시큐리티`, `스프링 Rest Docs`, `스프링 배치`, `스프링 클라우드` 등을 선택해 추가할 수 있다. [spring.io/projects](https://spring.io/projects)에 가면 다양한 기술이 있고, 이러한 기술을 편하게 사용하도록 도와주는 것이 **스프링 부트**이다.

필수를 다시 확인하면 이렇다.
- **스프링 프레임워크** : 핵심기술로서 DI 컨테이너, AOP, 이벤트 등을 활용한다. 그 외에도 웹 기술(MVC, WebFlux), 데이터 접근 기술(트랜젝션, JDBC, ORM 지원, XML 지원), 테스트 등을 갖는다.
- **스프링 부트** : 스프링 프레임워크를 편리하게 사용할 수 있는 도구로서 기본처럼 활용한다. 단독 실행이 가능한 스프링 애플리케이션을 쉽게 생성하고, Tomcat과 같은 **웹 서버를 내장**하여 별도로 웹 서버를 설치할 필요가 없다. 또한 빌드 구성을 쉽게 할 수 있고, 외부의 라이브러리도 자동으로 구성한다.

### 스프링의 핵심
스프링이 가장 큰 사랑을 받는 이유는, 자바 언어가 갖는 **객체 지향 언어**의 특성을 가장 잘 활용할 수 있는 프레임워크이기 때문이다. DI 컨테이너 등을 통해, 객체지향 프로그래밍을 가능하도록 해주기 때문이다.

### 객체지향 프로그래밍
캡슐화, 상속, 추상화, **다형성**으로 대표되는 성격들을 이용해, 변경에 용이한 구조로 만들 수 있다.  
예시를 통해 다시 이해해보면,
> - 운전자와 자동차를 예시로 들면, 자동차 모델은 어느 브랜드의 어느 차로 바꾸더라도 운전자는 운전할 수 있다. 전기차가 나오더라도 문제가 없다. 자동차가 바뀌더라도 운전자가 변할 필요가 없다. 이러한 세상에서, 자동차는 계속해서 새로운 세상으로 확장할 수 있다.   
> - 로미오와 줄리엣에서 어떠한 배우가 로미오, 줄리엣을 연기하더라도 문제가 발생하지 않는다. 배우가 바뀌더라도 상대 배역에 영향을 주지 않는다.

위의 예시는 **역할**과 **구현**을 분리한 경우의 사례이다. 이렇듯 객체를 설계할 때 역할과 구현을 분리하여 처리하면 클라이언트는 인터페이스를 통해 연결하고, 내부 구현체가 변경되어도 작동 흐름에 장애가 없다.  
이러한 설계가 가능하려면, 많은 객체가 서로 협력하는 관계를 이해해야 한다. 클라이언트를 변경하지 않고도, 서버의 구현 기능을 유연하게 변경할 수 있다.

역할 자체가 변하면, 모두에 큰 변경이 발생하기 때문에 **인터페이스를 안정적으로 설계**하는 것이 중요하다. 이러한 작업을 편리하게 할 수 있도록 **제어의 역전**, **의존성 주입**을 통해 스프링에서 제공하고 있다.

### SOLID(객체 지향 설계의 5가지 원칙)
- SRP(단일 책임 원칙) : 하나의 책임만 갖는다. **변경**이 있을 때, 파급 효과가 적다면 해당 원칙을 잘 준수한 것이다.
- **OCP(개방 폐쇄 원칙)** : **다형성**을 활용하여 확장에는 열려있고, 변경에는 닫힌 형태를 구현한다. 역할과 구현의 분리를 잘 해주어야 한다.  
그런데, 구현 객체를 변경하려면 클라이언트를 변경해야한다.
> ```java
> MemberRepository m = new MemoryMemberRepository();  // 기존 코드
> MemberRepository m = new JdbcMemberRepository();    // 변경 코드
> ```
이를 해결하기 위해 객체를 생성하고 연관 관계를 맺어주는 별도의 조립, 설정자가 필요하다. ~~(이것이 빈의 역할?)~~
- LSP(리스코프 치환 원칙) : 역할(인터페이스)가 정한 규악을 모든 구현체가 만족할 수 있도록 구현해야 한다. (모두가 해당 동작에 신뢰성을 가져아 한다!)
- ISP(인터페이스 분리 원칙) : 역할(인터페이스)를 적당한 단위로 나누어, 명확하게 설계한다.
- **DIP(의존관계 역전 원칙)** : **역할(인터페이스)에 의존**해야 한다. 특정 구현체에 종속된 설계를 하면 안된다.
> 예시에서 자동차를 비교로 든다면, 전기차에만 종속된 설계를 하게 되면 안된다. '자동차'의 역할에 집중한 코드를 처리해야 한다.

그럼에도, 구현체에도 의존하는 경우가 있다.
```java
MemberRepository m = new MemoryMemberRepository();
```
는 구현 클래스에도 의존하고 있기 때문에 DIP 위반 형태이다. 이를 위반하지 않도록 설계하는 방법을 찾아야한다.  

위와 같은 5가지 원칙을 지키기 위해서는, 다형성만으로 해결할 수 없다. OCP와 DIP를 지키기 위해서 다른 방법이 필요하다.  
이 방법이 바로 스프링의 의존성 주입, 제어의 역전을 통해 이뤄지는 DI 컨테이너다.

### 제어의 역전(IOC)
프로그램의 제어 흐름을 직접 하는 것이 아닌, 프로그램의 진행에 맡기는 방법. 언제 해당 객체가 생성되고 사용될지는 프로그램의 진행(예제 코드에서는 `AppConfig`)에 맡기는 것이다. 이렇듯 제어를 외부에서 관리하는 것을 **제어의 역전**이라고 한다.

### 의존 관계 주입 (DI)
인터페이스에 의존하기 때문에, 어떠한 구현 객체가 사용될지는 모른다. **정적인 클래스 의존 관계**와, **실행 시점에 결정되는 동적인 객체(인스턴스) 의존 관계**를 분리하여 판단한다면 구분이 수월하다. 클라이언트의 코드를 수정하지 않고, 모듈의 교환이 가능하도록 한다. 정적인 클래스(주로 인터페이스)의 관계는 유지한채, 동적인 객체 인스턴스(구현체) 의존관계는 쉽게 변경이 가능하기 때문이다.

### IoC 컨테이너, DI 컨테이너
객체를 생성하고 관리하면서 **의존관계를 연결**해주는 것을 **DI 컨테이너**라고 한다. 예제 코드에서는 `AppConfig`가 이를 담당한다. 의존관계 주입을 이룸으로써 SOLID를 준수하도록 도와준다.
