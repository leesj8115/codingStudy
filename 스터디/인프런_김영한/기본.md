# 스프링 스터디 - 2회

## 개요
[스프링 핵심 원리 기본편](https://www.inflearn.com/course/스프링-핵심-원리-기본편)을 보고 정리하는 스터디

## 기간
2021.08.30 ~ 09.05 (7일간)

## 목표
기술을 사용하는 것에서 떠나, 어떻게 실무에서 활용하는지와 원리, 핵심을 중점으로 확인한다. 이를 통해 단순한 사용보다 더 깊은 이해와 설계가 가능하도록 한다.

## 스프링
스프링 이전에는, Enterprise Java Beans(EJB)라는 기술이 표준 기술이었다. 이론은 정말 좋았지만, 어렵고 비쌌다. 이를 대체하면서 더 좋은 방법을 만들게 되었고 이것이 Spring의 시작이 되었다. 이 과정에서 Hibernate를 이용해 JPA 표준을 만들어지곤 했다.

처음에는 xml과 함께 많은 기능을 사용했는데, 스프링 프레임워크에서는 서버 기능 등을 따로 추가하고 관리해야했다. 스프링 부트가 추가되면서 프로젝트 구성을 편리하게 할 수 있고, 리액티브 프로그래밍(데이터의 흐름에 따라 처리하는 프로그래밍 방향. 데이터가 변경될 때마다 이벤트를 발생시킨다.)을 지원하게 됐다.

지금의 스프링은 스프링 프레임워크를 사용한 그 생태계 전반을 일컫는 용어로서 사용하고 있다.

### 스프링의 기술들
스프링은 여러 기술들의 모음으로 볼 수 있다. 필수로 `스프링 프레임워크`와 `스프링 부트`를 묶어서 보고, 필요에 따라 `스프링 데이터`, `스프링 세션`, `스프링 시큐리티`, `스프링 Rest Docs`, `스프링 배치`, `스프링 클라우드` 등을 선택해 추가할 수 있다. [spring.io/projects](https://spring.io/projects)에 가면 다양한 기술이 있고, 이러한 기술을 편하게 사용하도록 도와주는 것이 **스프링 부트**이다.

필수를 다시 확인하면 이렇다.
- **스프링 프레임워크** : 핵심기술로서 DI 컨테이너, AOP, 이벤트 등을 활용한다. 그 외에도 웹 기술(MVC, WebFlux), 데이터 접근 기술(트랜젝션, JDBC, ORM 지원, XML 지원), 테스트 등을 갖는다.
- **스프링 부트** : 스프링 프레임워크를 편리하게 사용할 수 있는 도구로서 기본처럼 활용한다. 단독 실행이 가능한 스프링 애플리케이션을 쉽게 생성하고, Tomcat과 같은 **웹 서버를 내장**하여 별도로 웹 서버를 설치할 필요가 없다. 또한 빌드 구성을 쉽게 할 수 있고, 외부의 라이브러리도 자동으로 구성한다.

### 스프링의 핵심
스프링이 가장 큰 사랑을 받는 이유는, 자바 언어가 갖는 **객체 지향 언어**의 특성을 가장 잘 활용할 수 있는 프레임워크이기 때문이다. DI 컨테이너 등을 통해, 객체지향 프로그래밍을 가능하도록 해주기 때문이다.

### 객체지향 프로그래밍
캡슐화, 상속, 추상화, **다형성**으로 대표되는 성격들을 이용해, 변경에 용이한 구조로 만들 수 있다.  
예시를 통해 다시 이해해보면,
> - 운전자와 자동차를 예시로 들면, 자동차 모델은 어느 브랜드의 어느 차로 바꾸더라도 운전자는 운전할 수 있다. 전기차가 나오더라도 문제가 없다. 자동차가 바뀌더라도 운전자가 변할 필요가 없다. 이러한 세상에서, 자동차는 계속해서 새로운 세상으로 확장할 수 있다.   
> - 로미오와 줄리엣에서 어떠한 배우가 로미오, 줄리엣을 연기하더라도 문제가 발생하지 않는다. 배우가 바뀌더라도 상대 배역에 영향을 주지 않는다.

위의 예시는 **역할**과 **구현**을 분리한 경우의 사례이다. 이렇듯 객체를 설계할 때 역할과 구현을 분리하여 처리하면 클라이언트는 인터페이스를 통해 연결하고, 내부 구현체가 변경되어도 작동 흐름에 장애가 없다.  
이러한 설계가 가능하려면, 많은 객체가 서로 협력하는 관계를 이해해야 한다. 클라이언트를 변경하지 않고도, 서버의 구현 기능을 유연하게 변경할 수 있다.

역할 자체가 변하면, 모두에 큰 변경이 발생하기 때문에 **인터페이스를 안정적으로 설계**하는 것이 중요하다. 이러한 작업을 편리하게 할 수 있도록 **제어의 역전**, **의존성 주입**을 통해 스프링에서 제공하고 있다.

### SOLID(객체 지향 설계의 5가지 원칙)
- SRP(단일 책임 원칙) : 하나의 책임만 갖는다. **변경**이 있을 때, 파급 효과가 적다면 해당 원칙을 잘 준수한 것이다.
- **OCP(개방 폐쇄 원칙)** : **다형성**을 활용하여 확장에는 열려있고, 변경에는 닫힌 형태를 구현한다. 역할과 구현의 분리를 잘 해주어야 한다.  
그런데, 구현 객체를 변경하려면 클라이언트를 변경해야한다.
> ```java
> MemberRepository m = new MemoryMemberRepository();  // 기존 코드
> MemberRepository m = new JdbcMemberRepository();    // 변경 코드
> ```
이를 해결하기 위해 객체를 생성하고 연관 관계를 맺어주는 별도의 조립, 설정자가 필요하다. ~~(이것이 빈의 역할?)~~
- LSP(리스코프 치환 원칙) : 역할(인터페이스)가 정한 규악을 모든 구현체가 만족할 수 있도록 구현해야 한다. (모두가 해당 동작에 신뢰성을 가져아 한다!)
- ISP(인터페이스 분리 원칙) : 역할(인터페이스)를 적당한 단위로 나누어, 명확하게 설계한다.
- **DIP(의존관계 역전 원칙)** : **역할(인터페이스)에 의존**해야 한다. 특정 구현체에 종속된 설계를 하면 안된다.
> 예시에서 자동차를 비교로 든다면, 전기차에만 종속된 설계를 하게 되면 안된다. '자동차'의 역할에 집중한 코드를 처리해야 한다.

그럼에도, 구현체에도 의존하는 경우가 있다.
```java
MemberRepository m = new MemoryMemberRepository();
```
는 구현 클래스에도 의존하고 있기 때문에 DIP 위반 형태이다. 이를 위반하지 않도록 설계하는 방법을 찾아야한다.  

위와 같은 5가지 원칙을 지키기 위해서는, 다형성만으로 해결할 수 없다. OCP와 DIP를 지키기 위해서 다른 방법이 필요하다.  
이 방법이 바로 스프링의 의존성 주입, 제어의 역전을 통해 이뤄지는 DI 컨테이너다.

### 제어의 역전(IOC)
프로그램의 제어 흐름을 직접 하는 것이 아닌, 프로그램의 진행에 맡기는 방법. 언제 해당 객체가 생성되고 사용될지는 프로그램의 진행(예제 코드에서는 `AppConfig`)에 맡기는 것이다. 이렇듯 제어를 외부에서 관리하는 것을 **제어의 역전**이라고 한다.

### 의존 관계 주입 (DI)
인터페이스에 의존하기 때문에, 어떠한 구현 객체가 사용될지는 모른다. **정적인 클래스 의존 관계**와, **실행 시점에 결정되는 동적인 객체(인스턴스) 의존 관계**를 분리하여 판단한다면 구분이 수월하다. 클라이언트의 코드를 수정하지 않고, 모듈의 교환이 가능하도록 한다. 정적인 클래스(주로 인터페이스)의 관계는 유지한채, 동적인 객체 인스턴스(구현체) 의존관계는 쉽게 변경이 가능하기 때문이다.

### IoC 컨테이너, DI 컨테이너
객체를 생성하고 관리하면서 **의존관계를 연결**해주는 것을 **DI 컨테이너**라고 한다. 예제 코드에서는 `AppConfig`가 이를 담당한다. 의존관계 주입을 이룸으로써 SOLID를 준수하도록 도와준다.

### 스프링 컨테이너 활용
```java
// AppConfing appConfing = new AppConfing(); // AppConfig에서 모든 것을 결정
// MemberService memberService = appConfing.memberService();

ApplicationContext applicationContext = new AnnotationConfigApplicationContext(AppConfing.class);
MemberService memberService = applicationContext.getBean("memberService", MemberService.class);
```
기존의 코드에서는 `AppConfig` 객체를 직접 생성하고, 해당 객체에서 필요한 서비스 구현체를 가져왔다. 스프링을 사용하면서(정확히는, DI 컨테이너를 사용하면서), `@Configuration`과 `@Bean` 어노테이션을 통해 등록해주고 필요한 객체를 컨테이너에서 가져오도록 했다. `applicationContext.getBean()` 메소드를 통해 Bean으로 등록한 이름을 통해 조회한다. `AnnotationConfigApplicationContext`는 `ApplicationContext`의 구현체이다. 그리고 `ApplicationContext`는 `BeanFactory`를 상속하고 있다.

- `BeanFactory` : 스프링 컨테이너의 최상위 인터페이스. 빈을 관리하고 조회하는 역할을 담당하며, 기본적인 기능(`getBean()` 등)을 제공한다.
- `ApplicationContext` : BeanFactory 및 다른 인터페이스를 상속하여 다양한 기능을 제공한다. (메시지 소스를 활용한 국제화 기능, 환경 변수, 애플리케이션 이벤트, 편리한 리소스 조회 등..)

XML이나 스프링 코드를 통해 전달받은 정보를 통해 컨테이너를 구성한다. 이 때 메타 정보인 `BeanDefinition`을 구성한다. 직접 구성하여 사용할 수도 있다.

## 싱글톤
스프링은 태생부터 기업용 온라인 서비스를 지원하기 위해 탄생했다. 즉, 수 많은 고객이 **동시에 요청하는 환경**을 처리하기 위함이 목적이다. 이러한 요청이 들어올 때마다 객체를 생성하면, 메모리 낭비가 심하다. 이를 해결하기 위해 **객체를 1개만 생성하고 공유**한다. 이러한 방식을 **싱글톤 패턴**으로 부른다.

어떻게 하면 객체를 1개만 생성할지에 대해 고민해야한다. 보통 `static final`과 `private 생성자`를 활용한다. `static`을 통해 하나만 만들고, 외부에서 임의의 객체를 생성(`new`를 통한 객체 생성)할 수 없도록 제한한다. 방법은 여러가지가 있지만, 스프링에서 해결해준다! (여러 패턴에 대해서는 학습하는 게 좋으나, 여기서 싱글톤 패턴의 구현 방법에 대해 파고들지는 않는다)

스프링에서는 패턴을 적용하지 않아도 객체 인스턴스를 싱글톤으로 관리한다. 내부에서는 CGLIB의 내부 기술을 이용해서 우리가 작성한 임의의 다른 클래스를 이용하여 싱글톤을 보장해주고 있다. (`@Configuration`)


스프링 컨테이너가 이를 관리한다! 편리하게 사용할 수 있지만 여러 주의점을 고려해야 한다.  
- 특정 클라이언트에 의존적인 필드가 있으면 안된다
- 가급적 읽는 형태로 활용한다. (클라이언트가 값을 변경하는 필드가 있으면 안된다)
- 값을 공유할 때 사용하면 큰 문제가 발생한다. (?)

## 컴포넌트 스캔
기존까지의 예제에서는 직접 빈을 등록하는 방법을 다뤘다. 모듈의 교환에는 유리할 수 있지만, 수 많은 객체에 대해 일일히 설정을 작성하는 것이 불필요한 반복일 수 있다. 이를 편리하게 하기 위해 컴포넌트 스캔 기능을 제공한다.
```java
@Configuration
@ComponentScan(
  excludeFilters = @ComponentScan.Filter(type = FilterType.ANNOTATION, classes = Configuration.class)
)
public class AutoAppConfig {
  // 등록할 빈들..
}
```
우선 예제 코드에서는 기존 코드를 지우지 않기 위해 `AppConfig.java` 를 그대로 유지해서, `@Configuration`이 붙은 기존 코드도 객체 관리 대상에 포함된다. 보통 특정 객체를 필터링하는 경우는 없으나, 기존 코드를 유지하기 위해 했음을 참고한다.

`@ComponentScan`은 `@Component`가 붙은 클래스를 모두 빈으로 등록한다. 다만 빈의 이름은 인터페이스가 아닌 어노테이션이 붙은 구현체 클래스의 이름이 그대로 부여된다. 이름을 지정하여 `Component("MemberService")`처럼 처리할 수도 있다.

`ComponentScan`에 추가 옵션이 있다.
- includeFilters : 추가할 목록
- excludeFilters : 제외할 목록
- basePackages : 탐색 시작 패키지 위치를 지정한다. 이것 포함 하를 검색한다.
- basePackageClasses : 지정 클래스가 속한 패키지부터 검색을 시작한다.  

옵션을 지정하지 않는다면, `@ComponentScan`이 속한 패키지가 시작 위치이다. 설정 파일을 프로젝트 최상단에 두고, 불필요한 걸 필터를 통해 제거하는 것을 권장한다. (excludeFilters는 사용하지만, includeFilters는 자주 사용 안한다.)

### 기본 스캔 대상
스캔 대상으로 `@Component` 말고도 `@Controller`, `@Service`, `@Repository`, `@Configuration`도 스캔 대상이 된다. (각 애노테이션들이 사실 Component를 포함하고 있다.) 또한 해당 어노테이션에 대해 부가 기능을 수행한다.
- Controller : 스프링 MVC 컨트롤러로 인식
- Repository : DB에 접근하는 예외를 스프링 예외로 변환해준다.
- Configuration : 싱글톤을 유지하도록 처리

### 빈이 충돌 될 경우
- 자동 빈 vs 자동 빈 : `BeanDefinitionStoreException` 발생
- 수동 빈 vs 자동 빈 : 수동 빈이 우선권을 갖고, overrieding 한다(`Overriding bean definition for bean '${빈 이름}' with a different definition`). 이렇게 보면 좋은 것 처럼 보이나, 개발자가 생각하기 어려운 상황(**명확하지 않은 상황**)을 만들 수 있다. 때문에 스프링 부트는 애플리케이션 실행시에 오류가 나도록 처리했다. `application.properties`에서 `spring.main.allow-bean-definition-overriding=true`로 설정하면 실행이 가능하긴 하다.

### 의존관계 주입 방법
입문 편에서도 한 번 확인했지만, 주입 방법에 대해 다시 확인해본다. 스프링 빈을 등록하고 `@Autowried`로 의존 관계를 주입하는 작업이 이루어지되, 어떠한 메소드에 지정하느냐에 따른 차이가 있다.
- 생성자 주입 : 1번 호출이 보장되므로, **불변, 필수** 의존 관계에 사용. 객체 생성과 의존 관계 주입이 함께 이루어진다.  
생성자 주입을 DI 프레임워크 대부분이 권장하는 상황이다. 그 이유는 위에서 나열한 효과 때문이다.
  * : 불변하기 때문에, 누군가 실수로 변경할 수 있는 가능성 자체를 없앤다.
  * : 생성자 주입을 사용하면, 필요한 구현체를 조합하여 테스트를 하는데 유용하다. (개발자도 의존관계를 확인하기 용이하다.)
  * : `final` 키워드 덕분에 반드시 의존관계를 확인하게 도움이 된다. (설정이 안되어있으면 컴파일 오류가 발생하니까!)

- 수정자 주입 (setter) : **선택, 변경** 가능성이 있는 의존 관계에 사용. 생성 이후 setter에 의해 의존 관계 주입이 이루어진다. (선택적일 경우에는 `@Autowired(required = false)`로 처리)
- ~~필드 주입~~ : 직접 필드에 주입하는 방법. **외부에서 변경 불가능**하고 테스트(더미데이터로 변경해서 확인할 때 등..)에 어려움이 있으니 가급적 사용 자제 (권장하지 않는 방법. 테스트 코드 내부 혹은 `@Configuration`같은 곳의 특별한 곳에서 활용..할 수 있지만 초심자에서는 가급적 자제하는 편이 좋겠다.)
- 일반 메서드 주입 : `init(A a, B b)`처럼 일반 메소드에 어노테이션을 붙여서 주입하는 방식. 여러 관계를 한 번에 주입 할 수 있다. 다만 잘 사용하지는 않는다.

### 선택적 의존 관계 주입
선택적 의존 관계 주입 처리를 위해, 3가지 방안이 제공된다.
- `@Autowired(required = false)` : 메소드 호출 자체가 제한
- `@Nullable` : 파라메터에 붙여서 사용. 주입 대상이 없으면 null을 가져온다.
- `Optinal<>` : 파라메터 타입으로 사용. 주입 대상이 없으면 `Optional.empty`를 가져온다.

### 롬복
`lombok` 라이브러리를 통해 기존의 코드를 더욱 간결화할 수 있다. `@Getter`, `@Setter`, `@RequiredArgsConstructor` 등을 적용하여 코드를 간결하게 보이게 할 수 있다. (실제 코드는 잘 만들어져있다!) 이 외에도 여러 어노테이션이 있다. (`@Data`, `@AllArgsContstructor` 등)

### 빈의 중복이 일어날 경우 해결법
자동 주입인 `@Autowired`를 이용하여 의존 관계를 연결했다. 다만, 여러 개의 빈이 있다면 `BeanDefinitionStoreException`이 발생함을 앞에서 확인했다. 이를 해결항 방법에 대해 알아본다.
- 의존관계를 설정할 때, 필드 명을 특정 빈 이름으로 지정 : 필드명(파라미터 명)을 빈의 이름과 매칭하여 특정 객체를 지정할 수 있다.
- `@Qualifier` 사용 : 빈을 구분할 수 있는 **추가 구분자**를 사용. 빈의 이름을 변경하는 것은 아님. 별도의 이름(식별자)를 등록하고, 자동 주입시에 해당 식별자와 일치하는 빈을 찾아 연결한다. 빈의 이름과 다른 것이기 때문에, 식별자끼리의 구분으로만 사용해야한다. 때문에 모든 코드에 Qualifier가 붙게된다.
- `@Primary` 사용 : 우선순위를 지정하는 방법. 중복된 빈 중에서도 우선 순위가 높은 빈을 사용한다. 자주 사용한다.  

이에 더해서, Qualifier에서 이름을 지정할 때 오타 등을 컴파일에서 잡아줄 수 없다. 이러한 문제를 더 확실하게 해결하고자 여러 어노테이션을 조합해서 사용한다. 특히 사용자 어노테이션을 만들어 거기에 여러 어노테이션을 조합해서 사용하면, 실사용 구역에서도 편리하게 사용할 수 있다.

### 자동 vs 수동
자동 주입을 선호하는 추세이다. 설계와 동작을 명확하게 나누느 것이 이상적이나, 매번 주입 대상에 대한 정보를 일일히 적어주는 것이 번거로운 과정이다. 때문에 자동 주입을 애용한다. (자동으로 해도 OCP, DIP는 지킬 수 있다!)

그러면 **수동은 언제** 사용할까. 업무 로직 빈(비즈니스 요구사항에 따라 추가/변경되는 것)에는 컨트롤러, 서비스, 리포지토리 처럼 패턴이 정해져있어 자동 주입을 적극 사용한다. 하지만 기술 지원 빈(기술적인 문제 혹은 공통 관심사(AOP)를 처리할 때 사용)은 광범위한 영역에 영향을 끼치는 것들의 모음이어서 문제 발생시 명확한 원인을 찾기가 어렵다. 이러한 빈들은 수동 주입을 통해 명확하게 설정 정보가 드러나도록 하는 게 좋다.  
혹은 의존 관계가 여럿이 있을 경우에는, 수동 주입을 통해 하나의 설정 파일, 특정 패키지에 묶어두는 것이 코드를 이해하는데 유용하게 작용한다.

## 빈의 생존주기
스프링 빈은 '객체 생성 -> 의존관계 주입'의 생존 주기를 갖는다. 객체 생성 이후가 아닌, 의존관계 주입까지 끝났을 때가 비로소 빈의 사용 준비가 완료된 것이다. 그렇다면, 어떻게 그 완료된 시점을 알 수 있는가?  
이를 알려주기 위해 **콜백 메서드**를 통해 초기화 시점을 알려주며, 종료 직전에 소멸 콜백을 주기도 한다. 이에 따라 추가 작업을 줄 수 있다. 따라서 스프링 빈의 이벤트 생존주기는 다음과 같이 이뤄진다.
> 스프링 컨테이너 생성 -> 스프링 빈 생성 -> 의존 관계 주입 -> **초기화 콜백** -> 사용 -> **소멸 전 콜백** -> 스프링 종료  

이러한 분리가 이뤄진 이유는 객체의 생성과 초기화를 분리해야하기 때문이다. 객체 생성은 메모리 할당이라는 중요한 작업이기 때문에 가볍게 우선적으로 이뤄져야하고, 초기화 작업에서 여러 값의 선언이나 외부 커넥션이 이뤄질 수 있다. 이러한 작업은 서로 나누어두는 것이 유지보수에 좋다.

### 콜백 처리 방법
- ~~인터페이스 `InitializingBean`, `DisposableBean` 추가~~ : 해당 빈에 대해 인터페이스를 추가하면 `afterPropertiesSet()`과 `destroy()`를 구현하면 각각 초기화, 종료 직전에 대한 처리를 더할 수 있다. 다만 인터페이스로 구현되다보니 스프링 전용 인터페이스에 의존해야하며, 함수 이름을 변경할 수도 없다. 그리고 외부에서 받은 라이브러리에서 해당 방법을 사용할 수는 없다. 지금은 거의 사용 안한다.
- `@Bean(initMethod = , destoryMethod = )` : 빈을 등록할 때 콜백 메소드를 지정할 수 있다. 위에서 발생한 문제점 (스프링 코드 의존, 메서드 이름 고정)을 해결했다. 또한 외부 라이브러리에도 빈을 등록할 때 똑같이 적용하여 처리할 수 있다.
  * 특별한 기능이 있다. `destoryMethod`는 기본 값으로 `close`나 `shutdown`이름의 메소드를 추론하여 지정하게끔 되어있다. 종료 메소드를 굳이 지정하지 않아도, 해당 이름의 메소드를 콜백 메소드로 자동 지정할 수 있다. 이러한 추론 사용 기능이 싫다면 `destoryMethod = ""`로 처리할 수 있다.
- `@PostConstruct`, `@PreDestroy` 어노테이션 적용 : 콜백 메소드에 붙여서 사용. 최신 스프링에서 권장하는 방법. 자바 표준 기술로서 사용하기 때문에, 스프링이 아닌 다른 컨테이너에서도 사용할 수 있다. 단, 외부 라이브러리에는적용하기 어렵다.

## 빈 스코프
빈이 존재할 수 있는 범위. 언제까지 객체가 존재하는지에 확인할 수 있다.
- **싱글톤** : 기본 스코프. 스프링 컨테이너의 시작부터 종료까지 유지
- **프로토타입** : 프로토타입 빈의 생성, 의존관계 주입까지만 관여. (매우 짧은 범위 스코프)
- 웹 관련 스코프
  * **request** : 웹 요청 ~ 반환까지 유지되는 스코프
  * session : 웹 세션의 생성 ~ 종료까지 유지되는 스코프
  * application : 웹 서블릿 컨텍스와 같은 범위로 유지되는 스코프 (ServletContext는 웹 애플리케이션과 생명주기가 같다.)

### 프로토타입 스코프
프로토타입 빈을 요청하게 되면, 컨테이너는 매번 새로운 객체(빈)을 생성하고 반환한다. 반환한 이후에는 스프링 컨테이너에서 해당 빈을 관리하지 않는다. **스프링 컨테이너는 프로토타입 빈을 생성하고, 의존관계 주입, 초기화까지만 처리**한다. 이후 관리는 클라이언트에게 맡겼기 때문에, 종료 메소드(`destory()`)이 실행되지 않는다. (실행하고 싶다면 직접 호출해야 한다.)

다만, 싱글톤 객체에서 프로토타입 빈을 호출할 경우에는 기존의 빈이 호출된다. (관리 대상에서 벗어난 그 객체가 참조되어서!) 이를 해결하고자 자바 표준의  `JSR-330 Provider` 혹은 스프링이 제공하는 `ObjectProvider`를 사용한다.

### 스프링 부트 웹 라이브러리
`spring-boot-starter-web` 라이브러리를 추가하면 내장 톰캣 서버를 활용해서 웹 서버와 스프링을 함께 실행한다.

### 웹 스코프
웹 환경에서만 동작하며, 스프링이 종료 시점까지 관리한다.
- request : HTTP 요청이 반환될 때 까지 유지되는 스코프. 각각의 HTTP 요청마다 별도의 빈 인스턴스가 생성되고 관리된다.
- application : 서블릿 컨텍스트와 동일한 생명주기..
- websocket : 웹 소켓과 동일한 생명주기..

웹 스코프 중 request는 요청이 들어올 때만 객체가 생성된다. 하지만 스프링 컨테이너에서 빈을 요청하게 되면, 해당 객체가 없기 때문에 오류가 발생한다. 이것을 해결하기 위해서는 객체 생성 시점을 뒤로 미뤄야 한다. 이를 위해 앞에서 배운 `Provider`를 이용한다.
```java
private final ObjectProvider<MyLogger> myLoggerProvider;  // 요청마다 생성

// ...
MyLogger myLogger = myLoggerProvider.getObject(); // Provider를 통해 객체를 가져옴
```

### 프록시
더 간결한 코드를 위해, Scope 옵션에 `proxyMode`를 추가할 수 있다. 실제 나의 클래스가 아닌, (CGLIB 라이브러리를 통해) **가짜 프록시 객체**를 만들어 주입한다. 내부에서 진짜 빈을 요청하는 처리가 있기 때문에, 호출시에 진짜 객체를 가져온다. 프록시는 웹 스코프가 아니어도 사용할 수 있다.

### 위의 핵심 => 지연처리
위의 Provider와 프록시 객체를 통해 빈을 요청하는 시점까지 객제 조회를 지연 처리할 수 있다. 다만 스코프는 필요한 곳에만 사용해야 유지보수 부담을 줄일 수 있고, 프록시는 싱글톤과 비슷하지만 다르게 동작하기 때문에 주의해야한다.


## 후기
기존에 배웠던 내용에 이론과 '왜 이렇게 작업하는지'에 대한 이해를 적립할 수 있어서 좋았다. 특히 의존 관계 주입에서 기존에 배웠을 때는 의존 관계 주입이 얼마나 중요한지 모르고, 배웠던 하나의 방식만을 사용했다. (심지어 비권장하는 방법으로!) 이번 기회로 생성자를 통한 의존성 주입을 이해하게 되었고, 객체를 싱글톤 으로 관리하기 위한 스프링 컨테이너의 중요성 등 여러가지를 이해할 수 있었다.

기존에 막무가내로 배웠을 때는 어떻게 Restful한 API를 만들 수 있을까 감이 잡히질 않았는데, 더욱 간결하고 정형화된 코드를 보고 배우면서 조금은 뚜렷해졌다.
